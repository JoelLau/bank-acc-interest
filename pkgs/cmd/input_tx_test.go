package cmd_test

import (
	appctx "bank-acc-interest/pkgs/app-ctx"
	"bank-acc-interest/pkgs/cmd"
	"bank-acc-interest/pkgs/storage"
	"bytes"
	"io"
	"sync"
	"testing"
	"time"

	"github.com/shopspring/decimal"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestInpuxTransactionTest(t *testing.T) {
	t.Parallel()

	// NOTE: sleep for short duration so that app.Run() can write to buffer
	inputReader, inputWriter := io.Pipe()

	// NOTE: remember to run .Reset() after reading
	var outBuf bytes.Buffer

	store := storage.NewInMemoryStorage()
	require.Len(t, store.InterestRules, 0)

	appCtx := appctx.NewAppCtx(inputReader, &outBuf, store)
	inputTxCmd := cmd.InputTransactions{AppCtx: appCtx}

	var wg sync.WaitGroup
	var err error

	wg.Add(1)
	go func() {
		defer wg.Done()
		inputTxCmd.Execute()
	}()

	const msgPrompt = `Please enter transaction details in <Date> <Account> <Type> <Amount> format
(or enter blank to go back to main menu):`

	stutter()
	require.Contains(t, outBuf.String(), msgPrompt)
	outBuf.Reset()

	stutter()
	_, err = inputWriter.Write([]byte("20230626 AC001 D 100.00\n"))
	require.NoError(t, err)

	stutter()
	require.Contains(t, outBuf.String(), "Account: AC001\n| Date     | Txn Id      | Type | Amount |")
	outBuf.Reset()
}

func TestNewTransactionFromString(t *testing.T) {
	t.Parallel()

	for _, tt := range []struct {
		name   string
		given  string
		expect storage.BankTransaction
		err    error
	}{
		{
			name:  "Example from REQUIREMENTS.md",
			given: "20230626 AC001 W 100.00",
			expect: storage.BankTransaction{
				Date:   time.Date(2023, time.June, 26, 0, 0, 0, 0, time.UTC),
				ID:     "",
				Type:   "W",
				Amount: decimal.NewFromInt(100),
			},
			err: nil,
		},
		{
			name:   "Invalid Date format",
			given:  "20230626xxx AC001 W 100.00",
			expect: storage.BankTransaction{},
			err:    cmd.ErrInvalidInput,
		},
		{
			name:  "Case Insensitive Type",
			given: "20230626 AC001 d 100.00",
			expect: storage.BankTransaction{
				Date:   time.Date(2023, time.June, 26, 0, 0, 0, 0, time.UTC),
				ID:     "",
				Type:   "D",
				Amount: decimal.NewFromInt(100),
			},
			err: nil,
		},
		{
			name:   "Amount must be > 0",
			given:  "20230626 AC001 d -100.00",
			expect: storage.BankTransaction{},
			err:    cmd.ErrInvalidInput,
		},
		{
			name:   "2 DP precision",
			given:  "20230626 AC001 d 100.003",
			expect: storage.BankTransaction{},
			err:    cmd.ErrInvalidInput,
		},
		{
			name:   "Missing Number of Tokens",
			given:  "20230626 AC001 W ",
			expect: storage.BankTransaction{},
			err:    cmd.ErrInvalidInput,
		},
	} {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			have, err := cmd.ParseInsertBankTxParams(tt.given)
			require.ErrorIs(t, err, tt.err)

			// NOTE: `ID` field is not generated by this function
			assert.Equal(t, tt.expect.Date, have.Date)
			assert.Equal(t, tt.expect.Type, have.Type)
			assert.True(t, tt.expect.Amount.Equal(have.Amount))
		})
	}
}
